## Virtual Memory
Virtual Memory는 가상메모리라 불리며, 물리적 메모리 크기의 한계를 극복하기 위해 나온 기술이다.
프로세스를 실행할 때, 실행에 필요한 일부만 메모리에 로드하고 나머지는 디스크에 두는 것이다.
결과적으로 메모리에 작은 양의 주소 공간만 있으면 충분히 프로세스를 수행할 수 있고, 그에 따라 더 많은 프로그램을 동시에 실행할 수 있게 된다.

이처럼 현재 필요한 Page만 메모리에 올리는 것을 Demand Paging이라고 한다.

## VAS, Virtual Address Space( 가상 주소 공간 )
가상 주소 공간은 각 프로세스 당 주어지는 논리적인 공간으로 가상 주소 공간의 크기는 주 메모리( RAM )의 크기와는 독립적으로 레지스터 크기에 종속되어 있다.
만약, 32비트인 컴퓨터의 경우 레지스터의 크기도 32비트이다. 이것은 2^32 개의 주소를 나타낼 수 있음을 의미하고, 1Byte당 주소가 주어지므로 최대 4GB의 가상 주소 공간을 가질 수 있다.

## IPC, Interprocess Communication( 프로세스 간 통신 )
운영체제 내에서 실행되는 병행 프로세스들은 독립적이거나 또는 협력적인 프세스 일 수 있는데, 다른 프로세스들과 데이터를 공유하지 않으면 독립적, 영향을 주거나 받는다면 협력적인 프로세스이다.

프로세스가 협력을 허용하는 환경을 제공하는 것은 몇가지 이유가 있다.
- 정보 공유( information Sharing ), 계산 가속화( computation speedup ), 모듈성( modularity )

![](https://velog.velcdn.com/images/dymnam/post/4d8451f7-f1a0-4023-ae26-7bb31799f577/image.png)
위 그림을 보면 Process는 독립된 실행객체라고 말할 수 있다.
독립되어 있다는 것은 데이터를 공유하지 않으므로 다른 프로세스의 영향을 받지 않는다는 장점이 있다. 하지만, 독립되어 있는 만큼 별도의 설비가 없이는 서로 간 통신이 어렵다.

이를 해결하기 위해서 커널 영역에서 IPC라는 내부 프로세스간 통신을 제공하고, 프로세스는 커널이 제공하는 IPC기술을 이용하여 프로세스 간 통신을 할 수 있게 된다.

IPC에는 2가지의 종류가 존재한다.

- Massage Passing( 메세지 전달 )
![](https://velog.velcdn.com/images/dymnam/post/3abdd51d-32fc-429d-af13-2a4db3a93a64/image.png)
커널이 제공하는 API를 사용해서 커널을 통해 통신한다. 
메세지 전달은 분산 시스템에서 공유 메모리보다 구현하기 쉬운 장점이 있으며, 충돌을 회피할 필요가 없기 때문에 적은 양의 데이터를 교환하는데 유용하다.

- Shared Memory( 메모리 공유 )
![](https://velog.velcdn.com/images/dymnam/post/db08f932-3370-468b-90ab-d0452df47b77/image.png)
프로세스끼리 특정 공통의 메모리 영역을 공유하여 통신하는 방법이다.
공유 메모리 모델은 메시지 전달 모델보다 빠르며, 공유 메모리 영역을 구축할때만 시스템 콜이 필요하다. 또한, 공유메모리 영역이 구축되면 모든 접근은 일반적인 메모리 접근으로 취급되어 커널의 도움이 필요가 없다.

공유 메모리 영역은 공유 메모리 세그먼트를 생성하는 프로세스의 주소 공간에 위치하며, 이 공유 메모리 세그먼트를 이용하여 통신하고자 하는 다른 프로세스들은 이 세그먼트를 자신의 주소 공간에 추가하여야 한다.

공유 메모리는 둘 이상의 프로세스가 이 제약 조건을 제거하는 것에 동의하는 것을 필요로하며, 우리는 일반적으로 운영체제는 한 프로세스가 다른 프로세스의 메모리 접근하는 것을 금지한다는 것을 기억해야한다.

## Demand Paging( 요구 페이징 )
Demand Paging : 요청 시( 페이지 오류가 발생할 때마다 ) 메모리에 페이지를 로드하는 프로세스를 요청 페이징이라고 한다.
![](https://velog.velcdn.com/images/dymnam/post/5122da32-441f-4ff6-8c64-f78bbc3195cd/image.png)

1. CPU가 현재 주 메모리( RAM )에서 사용할 수 없는 페이지를 참조하려고 하면 메모리 엑세스 오류를 나타내는 인터럽트가 생성된다.

2. OS는 중단된 프로세스를 차단 상태로 만든다. 실행을 진행하려면 OS가 필요한 페이지를 메모리로 가져와야함.

3. OS는 논리적 주소 공간에서 필요한 페이지를 검색한다.

4. 필요한 페이지는 논리적 주소 공간에서 물리적 주소 공간으로 가져온다.
-> 페이지 교체 알고리즘은 물리적 주소 공간에서 페이지 교체를 결정하는 데 사용된다.

5. 이에 따라 페이지 테이블이 업데이트된다.

6. 신호는 프로그램 실행을 계속하기 위해 CPU로 보내지고 프로세스를 준비 상태로 되돌린다.

#### Demand Paging 장점
- 더 많은 프로세스가 주 메모리에 유지될 수 있다.
- 프로세스는 모든 주 메모리보다 클 수 있다. 프로그래밍에서 가장 근본적인 제한 중 하나가 해제된다.
- 각 프로세스에 사용 가능한 메모리를 적게 사용하여 다중 프로그래밍 수준을 높일 수 있다.

## Page Fault
Paging을 지원하는 OS에서는 페이징 기술을 실현하기 위해 메모리를 페이지에 고정 크기 형태로 블럭화 해 관리한다.
페이지의 크기는 가상 메모리 공간의 크기가 되는데, 이 때 크기가 물리 메모리 공간보다 클 경우 그 여분은 보조기억장치( 디스크 )에 저장된다.
~~물리 메모리와 보조기억장치 간 페이지를 정책에 따라 교환(스왑)하는 것을 페이징 기술이라 한다.~~

만약, 물리 메모리에 CPU가 요청한 페이지가 없다면 그것이 Page Fault이다. 이 경우, swap 영역( 보조기억장치에 위치한 가상 메모리 영역 )에서 페이지를 찾아 물리 메모리에 로드한다.

Page Fault는 원인에 따라 3가지로 분류한다.

1. Marjor Page Fault
Marjor Page Fault는 일반적으로 Swapping으로 알려진 동작을 의미한다.
요청한 페이지가 물리 메모리로부터 Swap-out되어 보조기억장치의 가상 메모리에 저장되었다면 해당 페이지를 다시 물리 메모리로 Swap-in해야하는데 이것을 Major Page Fault라고 한다.

2. Minor Page Fault
요청한 페이지가 물리 메모리에는 로드 되었지만 메모리 관리 유닛( Memory Management Unit, MMU )에는 로드되어 있지 않다고 표시된 경우 이를 Minor Page Fault라고 한다.
-> I/O의 오류

3. Invalid Page Fault
블루 스크린의 원인이다. 요청한 페이지가 스왑 영역 밖을 참조하거나, 페이지를 쓰기 불가능한 영역에 쓰려고할 때 발생하는 Page Fault이다.

이 경우에는 Page Fault handler가 Segmentation Fault를 발생시킨다. 결과는 보통 커널 패닉( 블루 스크린 )으로 나타난다.

페이지 교체 알고리즘은 다양하다.
흔히 언급되는 것들은 다음과 같다.

- FIFO (First In First Out)
- Optimal Page Replacement
- LRU (Least Recently Used)
- LFU (Least Frequently Used)
- MFU (Most Frequently Used)

는 다음에 이어서 알아보겠당.

# Network

 이름 그대로 네트워크를 알아보자면 컴퓨터들이 통신 기술을 이용하여 그물망처럼 연결된 통신 이용 형태
 두 대 이상의 컴퓨터들을 연결하고 서로 통신할 수 있는 것
 = 연결을 통해서 컴퓨터끼리의 자원을 공유하는 것

IEEE에서의 네트워크 정의
 몇 개의 독립적인 장치가 적절한 영역 내에서 적당히 빠른 속도의 물리적 통신 채널을 통하여 서로가 직접 통신할 수 있도록 지원해주는 데이터 통신 체계

IEEE 802 위원회 LAN 표준안
- LAN 관련 표준화를 수행하는 표준화 기관으로, 대표적인 예가 무선 LAN 관련 표준인데, 무선 LAN은 모두 802.11로 시작한다
- 802.11로 시작하는 이유는 IEEE 802 위원회가 무선 LAN을 위해서는 약 50m의 전송거리, 11Mbps 전송 속도 등을 요구사항으로 정의했기 때문
- 조건을 만족하는 무선 LAN 표준들은 IEEE 802.11b, IEEE 802.11a 등이 있으며, 요구사항은 조금 더 발전해서 54Mbps, 100Mbps 등으로 변경되고 있음


＊ 네트워크 종류
![image](https://user-images.githubusercontent.com/97201374/185394369-d2b3ebbb-c2ac-4df6-a8c9-bf480ea9f3b2.png)


☞ PAN (Personal Area Network) : 가장 작은 규모의 네트워크

☞ LAN (Local Area Network) : 근거리 영역 네트워크
 - 한 건물이나 일정 지역 내에서 컴퓨터나 단말기들을 고속 전송 회선으로 연결하여 프로그램 파일 또는 주변장치를 공유할 수 있도록 한 네트워크 형태

장점 : 자원의 효율적인 백업이 가능
	다른 기종 간의 통신에서 사무 처리의 능률이 극대화
	파일 공유 처리의 효율화 및 통일된 관리과 가능
	분산 처리 시스템 전체의 성능이 향상되는 효과를 누릴 수 있다
특징 : 단일 기관의 소유이며, 제한된 지역 내의 통신
	광대역 전송 매체의 사용으로 고속 통신이 가능하며, 오류 발생률이 낮다
	공유매체의 사용으로 경로 선택 없이 매체에 연결된 모든 장치로 데이터 전송
	네트워크에 포함된 자원을 공유, 확장이나 재배치가 쉽다
	망의 구성 형태에 따라 성형, 버스형, 링형, 계층형 등으로 분류할 수 있다

☞ MAN (Metropolitan Area Network) : 대도시 영역 네트워크
 - LAN의 확장형 모델로 50km 반경 이내의 도시, 번화가, 아파트단지 등을 대상으로 구성하는 통신망을 일컫고, LAN의 제약과 WAN의 단점을 해소하기 위한 통신망이다

☞ WAN (Wide Area Network) : 광대역 네트워크
 - 일반적으로 제 3자에 의해 제공되고 운영되는 공중망을 말하며 LAN이 여러 개 모여 그들간의 고속 전송이 가능한 전용 회선으로 연결한다

☞ VAN (Value Added Network) : 부가가치 통신망 정보의 축적과 제공, 통신속도와 형식의 변화, 통신 경로의 선택 등 여러 정보의 정보서비스가 부가된 통신망

- 전송 기능(기본 통신 계층) : 사용자가 단순히 정보를 전송할 수 있도록 물리적 회선을 제공하는 VAN의 기본적인 기능
- 교환 기능(네트워크 계층) : 가입된 사용자들을 서로 연결시켜 사용자 간의 정보 전송이 가능하도록 제공하는 서비스이며, 패킷 교환 방식을 이용
- 통신 처리 기능(통신처리계층) : 축적 교환 기능과 변환기능을 이용하여 서로 다른 기종 간, 다른 시간대에 통신이 가능하도록 제공하는 서비스
- 정보 처리 기능(정보 처리 계층) : 온라인 실시간 처리, 원격 일괄 처리, 시분할 시스템 등을 이용하여 급여관리, 판매관리 DB 구축, 정보 검색, 소프트웨어 개발 등 응용 소프트웨어를 처리하는 기능

특징 : 불특정 다수의 대상으로 서비스를 제공
	패킷 교환망을 이용한 교환 서비스
	기업 간 전산망(EDI) 등과 공통적인 특성을 가진다


☞ ISDN (Integrated Services Digital Network) : 종합정보 통신망(BISDN) 전화, 팩스, 데이터 통신, 비디오텍스 등 통신과 관련된 서비스를 종합하여 다루는 통합서비스 디지털 통신망이며, 디지털 전송방식과 광섬유 케이블 사용, 꿈의 통신망이라 불림

＊ 네트워크 회선구성 방식
- 포인트 투 포인트 : 중앙 컴퓨터와 단말기를 일대일로 연결하여 언제든 데이터 전송이 가능
- 멀티 드롭 : 멀티 포인트 방식이라고도 하며, 다수의 단말기를 하나의 통신 회선에 연결
- 회선 다중 : 다중화 방식이라고도 하며, 여러 대의 단말기들을 다중화 장치를 활용하여 중앙 컴퓨터와 연결하여 사용

＊ 네트워크의 데이터 교환 방식
☞ 회선교환 : 통신을 원하는 두 지점의 교환기를 이용하여 물리적으로 접속시키는 방식 
	ex) 음성 전화 방식

회선을 독점하는 통신방식이라 볼 수 있음
송수신을 연결하는 전용선을 설정하고 전송하는 것이 핵심

장점 : 대용량 + 고속 데이터 처리에 우수
	고정적인 대역폭을 사용
	연속적인 데이터 처리에 우수하다
단점 : 회선 이용 효율이 떨어진다 (대역폭 낭비)
	통신과정에서 회선 문제시 회선 할당부터 다시 해야한다
특징 : 회선교환은 통신 회선을 설정하여 데이터를 교환하는 방식
	송신자의 모든 데이터는 동일한 경로로 전송
	Point-to-Point 방식으로 연결

☞ 공간분할교환 : 기계식 접점과 전자교환기의 전자식 접정 등을 이용하여 교환을 수행
	ex) 음성 전화용 교환기

☞ 시분할교환 : 전자부품이 갖는 고속성과 디지털 교환 기술을 이용하여 다수의 디지털 신호를 시분할적으로 동작시켜 다중화하는 방식

☞ 패킷교환 (Packet Switching) : 전송하려는 데이터를 패킷이라는 단위로 나눠 네트워크 망으로 뿌려줌
[ ※ 패킷이란? 
 - 네트워크를 사용해 전송하기 위해서 일정한 단위로 나눈 데이터 전송 단위
 - 데이터 송신자와 수신자가 하나의 단위로 처리하는 데이터 처리 단위 ]

 - 패킷에는 해당 데이터가 어떤 데이터의 몇 번째 데이터인지와 최종 목적지에 대한 정보가 담김
 - 정보를 토대로 라우터가 패킷을 최적 경로로 전달하게 된다
 - 최적경로는 단순히 거리만을 계산하는 것이 아니라 상황에 맞게 판단
 - 망의 혼잡도 (대역폭 사용률), 연결상태, 기타 설정 등에 따라 수시로 변경
 - 특정 데이터가 n개의 패킷으로 분해되어 전송 시
 - n개의 패킷은 라우터에 의해 서로 다른 경로로 전송될 수 있으며
 - 최종 목적지에 n개의 패킷이 전달되면 순서를 통해 원래의 데이터로 합쳐진다
![image](https://user-images.githubusercontent.com/97201374/185394406-01153bd0-338d-4cb0-a086-db47678451fb.png)

 - 패킷은 서로 다른 경로로 전송되므로 도착 시 순서와 다르게 수신될 수 있다

장점 : 회선의 이용률이 높다, 속도도 높으며 프로토콜 변환이 가능
	라우터 고장 시 즉각적으로 다른 경로를 찾으며, 에러에 대해 특정 패킷만을 전송
	인터넷뿐만 아니라 다양한 통신망에서도 사용 가능
	상황에 따라 패킷의 우회 전송이 가능하므로 전송의 신뢰성이 보장
	디지털 전송이기 때문에 오류 발생 시 재전송이 가능
단점 : 경로 탐색 과정에서 지연이 발생한다
	전송량 증가에 따라 지연율이 급격하게 상승한다
	패킷별 헤더 추가로 인해 오버헤드 발생이 가능
특징 : 전송되는 패킷은 패킷별로 최적의 경로를 선택하여 전송된다 (여러 경로로 공유)
	송신 패킷과 수신 패킷의 순서는 다를 수 있다
	전송 속도 및 흐름 제어가 가능하다 – 순서 제어를 통해 패킷의 순서를 정함
	패킷 정보를 통해서 에러 탐지가 가능하며 일반적인 인터넷망에서 사용된다

☞ 가상회선기술 (Virtual Circuit) : 패킷교환방식의 네트워크에서 회선교환과 같은 통신을 만들어주는 기술
 - 패킷단위로 데이터를 전송하지만, 사전에 구성된 특정 경로로 데이터를 전송하므로 모든 패킷은 동일한 경로를 통해 데이터가 전송
 - 정해진 경로로 데이터가 전송되어 순차적으로 패킷을 수신할 수 있다


＊ 네트워크 토폴로지 (Network Topolgy)
 물리적으로 연결된 형태에 따른 분류로, 통신망의 구조에 따른 분류

‘링크’ = 회선 : 두 노드를 연결하는 선으로 PC에 연결된 랜선으로 이해하는게 편함
‘노드’ : 네트워크의 데이터를 송수신, 데이터를 처리하는 장치
	PC(단말노드)와 라우터가 대표적

☞ 계층형 (Tree)
장점 : 네트워크의 관리가 쉽고, 새로운 장치 추가가 수월하다
	네트워크의 신뢰도가 높다
단점 : 트래픽 집중에 따른 속도 저하현상 발생 (병목현상)
	상위 노드 고장 시 상위 네트워크와의 통신이 불가능
![image](https://user-images.githubusercontent.com/97201374/185394446-edb258e0-8299-45cf-b734-99a327b36d72.png)


☞ 버스형 (Bus)
장점 : 설치비용이 저렴하고 신뢰성이 높다
	구조가 간단하며 새로운 노드 추가가 쉼다
단점 : 네트워크 병목현상 발생이 쉽다
	장애가 발생시 전체 네트워크 마비가 발생
특징 : 회선의 양 끝에는 터미네이터(Terminator)가 존재하여 신호의 반사를 차단
![image](https://user-images.githubusercontent.com/97201374/185394462-bb46d669-9f87-4939-a84a-c21f26228865.png)


☞ 선형 (Star)
장점 : 고속 네트워크에 적합하다
	노드 추가가 쉬우며 개별 링크 장애에도 네트워크에 영향이 없다
단점 : 중앙 노드 장애 발생 시 전체 네트워크 불통
	노드 증가에 따라 네트워크의 복잡도가 증가한다
![image](https://user-images.githubusercontent.com/97201374/185394472-58bcda08-8e60-4b81-9bf3-73d4d870d1b0.png)


☞ 링형 (Ring)
장점 : 저렴한 비용으로 네트워크 구성이 가능
	충돌현상이 발생하지 않는다
단점 : 네트워크 구성을 변경하기가 힘들다
	링크 장애 발생 시 전체 네트워크의 불통
특징 : Token Passing 기법 사용
![image](https://user-images.githubusercontent.com/97201374/185394489-190e1620-8c2d-4e74-a668-f2c7c86ae435.png)


Token Passing
- 토큰이라는 제어비트를 송신하고 해당 토큰을 확보해서 통신하는 방식
- 통신 회선에 대한 신호가 논리적으로 형성된 링에서 각 노드를 옮겨가며 데이터를 전송하는 방식
- 링 형태의 네트워크 토폴로지를 사용하며, 충돌이 발생하지 않는다

- 가변 길이의 데이터 프레임 전송이 가능
- 하드웨어 장비가 복잡하고 평균 대기 시간이 높음
- 부하가 높을 경우 안정적이고, 접근 시간이 대략적으로 일정한 값을 유지
- 특정한 비트 패턴으로 구성된 짧은 프레임 형태
- 통신 회선의 길이가 무제한이지만 확장성이 어렵다


☞ 망형 (Mesh)
장점 : 완벽하게 이중화 되어있어 장애에 강하다
	많은 양의 데이터 처리에도 문제없이 처리 가능
단점 : 구축과 운영 비용이 고가이다
![image](https://user-images.githubusercontent.com/97201374/185394501-e9eba3c3-e71c-4c03-a1db-14db665d8dd6.png)



## TCP
TCP/IP (Transmission Control Protocol / Internet Protocol)는 데이터가 의도된 목적지에 닿을 수 있도록 보장해주는 통신 규약
- TCP/IP를 사용하면 한 컴퓨터가 데이터 패킷을 컴파일하고 올바른 위치로 전송하여 인터넷을 통해 다른 컴퓨터와 통신할 수 있다
- TCP/IP는 전 세계에서 가장 일반적으로 사용되는 프로토콜 세트 중 하나이다
- 이와 비슷한 프로토콜인 X.25가 유럽에서 사용된다
- 하드웨어에 구애받지 않고 네트워크에 연결된 여러 호스트 사이의 통신을 허용한다

프로토콜 : 서로 다른 하드웨어와 운영체제 등이 서로 통신을 하기 위한 모든 요소의 규칙
 - 어떻게 상대를 찾을 것인가?
 - 어떻게 상대에게 이야기를 시작하는가?
 - 어떤 언어로 이야기하는가?
 - 어떻게 이야기를 종료해야 하는가?

TCP란? (전송 제어 프로토콜)
 - 최상위 계층인 TCP는 많은 양의 데이터를 가져와 패킷으로 컴파일한 다음 동료 TCP 계층에서 수신하도록 전송하여 패킷을 유용한 정보와 데이터로 바꿔주는 역할을 한다
 - TCP는 전달받은 패킷을 재조립한다
 - 패킷에 손상이나 손실이 있다면 재전송을 요청하는 패킷을 전송하여 재전송 받는다
 - 신뢰성 있는 데이터 전송을 지원하는 연결 지향형 프로토콜
 - 3-Way handshake 과정을 통해 연결을 설정하고 통신을 시작한다
 - 4-Way handshake 과정을 통해 연결을 해제한다
 - 흐름 제어, 오류 제어, 혼잡 제어를 통해 신뢰성을 보장한다

IP란?
 - 인터넷에서 컴퓨터의 위치를 찾아서 데이터를 전송하기 위해 지켜야 할 규약
 - 전 세계 수억대의 컴퓨터에게 서로의 정체를 알 수 있게 부여한 특별한 주소
 - IP는 4개의 숫자로 구성된다
 - IPv4(32비트, 각 숫자는 1바이트), IPv6(128비트, 각 숫자는 4바이트)로 나뉜다
 - IPv4는 10진수로 표현하며, 각 자리는 “ . ”으로 구분
 - IPv6는 4자리 16진수로 표현하며, 각 자리는 “ : ”로 구분
 - 맨 아래 계층인 IP는 올바른 목적지를 찾는 패킷 GPS 역할을 함

## TCP / IP의 4계층

![image](https://user-images.githubusercontent.com/97201374/185394523-a9dd4cf4-14de-4492-b791-34055ccbdc48.png)



OSI 7 계층을 더욱 추상화 한 TCP / IP 4계층
1. 네트워크 엑세스 계층 (물리계층, 데이터 링크 계층)
 - TCP / IP 패킷을 네트워크 매체로 전달
 - 네트워크 매체에서 TCP / IP 패킷을 받아들임
 - 에러 검출 기능, 패킷의 프레임화
 - 네트워크 접근 방법, 프레임 포맷, 매체에 대해 독립적으로 동작하도록 설계
 - 물리적 주소로 MAC을 사용
 - LAN, 패킷망 등에 사용

2. 인터넷 계층 (네트워크 계층)
 - 어드레싱(addressing), 패키징(packaging), 라우팅(routing) 기능을 제공
 - 네트워크상 최종 목적지까지 정확하게 연결되도록 연결성을 제공
 - 프로토콜 종류 : IP, ARP, RARP

3. 전송 계층 (전송 계층)
 - 애플리케이션 계층의 세션과 데이터그램 통신서비스 제공
 - 통신 노드 간 연결을 제어, 신뢰성있는 데이터 전송을 담당
 - 프로토콜 종류 : TCP, UDP

4. 응용 계층 (세션 계층, 표현 계층, 응용 계층)
 - 프로그램(브라우저)이 직접 인터렉트하는 레이어
 - 데이터를 처음으로 받는 곳
 - 다른 계층의 서비스에 접근할 수 있게 해주는 애플리케이션을 제공
 - 애플리케이션들이 데이터를 교환하기 위해 사용하는 프로토콜을 정의
 - HTTP, SMTP 등의 프로토콜을 가짐
 - TCP / UDP 기반의 응용 프로그램을 구현할 때 사용
 - 프로토콜 종류 : FTP, HTTP, SSH


### TCP 세그먼트 구조
 TCP는 데이터 스트림으로부터 데이터를 받아들여 이를 청크 단위로 분할한 뒤 TCP 헤더를 덧붙여 TCP 세그먼트를 생성
 TCP 세그먼트는 IP 데이터그램에 캡슐화되어 상대방과 주고받게 된다

 TCP 패킷이라는 용어가 종종 사용되지만 이는 정확한 표현이 아니다

 세그먼트가 TCP 프로토콜 데이터 유닛(PDU)을 의미하는 정확한 표현이며, 데이터그램은 IP PDU를, 프레임은 데이터 링크 PDU를 의미한다

 - 프로세스는 TCP를 통해 데이터 버퍼를 인수로 넘겨 줌으로써 데이터를 전송한다
 - TCP는 이 버퍼들을 묶어 세그먼트를 생성한다
 - 생성된 세그먼트들은 인터넷 모듈(IP 등)을 통해 목적지의 TCP로 각각 전송된다


### TCP 3 way handshake

 TCP 장치들 사이에 논리적인 접속을 성립하기 위해 사용하며, 데이터 전송하기 전에
사용자의 컴퓨터와 상대방 컴퓨터 사이에 세션을 수립하는 과정을 의미
이러한 절차는 TCP 접속을 성공적으로 성립하기 위해 반드시 필요하다

 - 양쪽 모두 데이터를 전송할 준비가 되었다는 것을 보장, 데이터 전달 전 서로가 준비되어 있다는 것을 알 수 있도록 한다
 - 양쪽 모두 상대방에 대한 초기 순차일련번호를 얻을 수 있다

![image](https://user-images.githubusercontent.com/97201374/185394545-433321d5-438d-4a68-b0b4-92bf0ccc9f83.png)


1. Client > Server : TCP SYN
 - A 클라이언트는 B 서버에 접속을 요청하는 SYN 패킷을 보낸다
 - A 클라이언트는 SYN을 보내고 SYN/ACK 응답을 기다리는 SYN_SENT 상태가 된다

2. Server > Client : TCP SYN ACK
 - B 서버는 SYN요청을 받고 A 클라이언트에게 요청을 수락한다는 ACK와 SYN flag가 설정된 패킷을 발송, A 클라이언트가 다시 ACK로 응답하기를 기다린다
 - B 서버는 SYN_RECEIVED 상태가 된다

3. Client > Server : TCP ACK
 - A 클라이언트는 B 서버에게 ACK를 보내고 이후로부터 연결, 데이터 송수신이 된다
 - B 서버 상태는 ESTABLISHED

### TCP 4 way handshake

 3-Way handshake는 TCP의 연결 초기화에 사용했다면, 4-Way는 세션을 종료하기 위해 수행하는 절차

![image](https://user-images.githubusercontent.com/97201374/185394568-b99e416e-4a6e-4735-8f5b-b6d26e0b5ac5.png)


1, 클라이언트가 연결을 종료하겠다는 FIN 플래그를 전송
2. 서버는 확인 메시지를 보내고 자신의 통신이 끝날 때까지 기다린다 : TIME_WAIT 상태
3. 서버가 통신이 끝났으면 연결이 종료되었다고 FIN 플래그를 전송
4. 클라이언트는 확인했다는 메시지를 보낸다

TIME_WAIT : SERVER에서 FIN을 전송하기 전에 전송된 패킷이 지연이나 유실 등에 의해 FIN 패킷보다 늦게 도착하는 상황이 발생하지 않도록 Client가 FIN을 수신하더라도 일정 시간 (디폴트)동안 세션을 남겨놓고 잉여 패킷을 기다리는 과정이라고 이야기할 수 있다

### 흐름 제어

 - 수신측과 송신측 사이의 데이터 처리 속도 차이를 해결하기 위한 기법
 - 송신측의 전송 속도가 수신측의 처리 속도보다 빠를 경우 전송된 패킷이 수신측의 큐를 넘어 손실될 수 있기 때문에 송신측의 패킷 전송량을 제어한다

1. Stop and Wait
 - 매번 전송한 패킷에 대한 확인 응답을 받아야 다음 패킷을 전송할 수 있따
 - 이러한 구조로 인해서 비효율적이다

2. Sliding Window
 - 수신측에서 설정한 윈도우 크기만큼 송신측에서 확인 응답 없이 세그먼트를 전송할 수 있게 하여 데이터 흐름을 동적으로 조절
 - 윈도우 : 송신, 수신측 양쪽에서 만들어진 버퍼의 크기
 - 전송되는 프레임 관리를 위해 각 프레임의 모듈러에 의한 번호체계가 부여
 - 번호는 윈도우보다 커야한다 (번호가 작을 경우 같은 윈도우에 같은 번호가 들어갈 수 있다)
![image](https://user-images.githubusercontent.com/97201374/185394587-3b284f72-435b-4aa3-bd3a-a40d6566b33d.png)


3. 동작방식
 - 송신측에서 먼저 윈도우에 포함되는 모든 패킷 0, 1, 2, 3, 4, 5, 6을 전송
 - 수신측에서 0, 1을 받은 상태면 송신측에 0, 1을 받았다고 ACK 프레임을 전달
 - 송신측 윈도우 크기를 ACK 프레임에 따라 옆으로 확장


### 오류 제어

 - 오류 검출과 재전송을 포함한다
 - ARQ기법을 사용해 프레임이 손상되었거나 손실되었을 경우, 재전송을 통해 오류를 복구
 - ARQ(Automatic Repeat Request)기법은 흐름 제어 기법과 관련이 있다

＊ ACK : 다음 프레임을 전송
＊ NAK : 손상된 프레임 자체 번호를 반환

1. Stop and Wait ARQ
 - 송신측에서 1개의 프레임을 송신하고, 수신측에서 수신된 프레임 에러 유부 판단에 따라 ACK or NAK를 보내는 방식
 - 식별을 위해 데이터 프레임과 ACK 프레임은 각각 0, 1번호를 번갈아가며 부여한다
 - 수신측이 데이터를 받지 못했을 경우, NAK를 보내고 송신측은 데이터를 재전송
 - 데이터나 ACK가 분실되었을 경우 일정 간격의 시간을 두고 타임아웃이 되면, 송신측은 데이터를 재전송한다

2. Go-Back-n ARQ (슬라이딩 윈도우)
 - 전송된 프레임이 손상되거나 분실된 경우
 - ACK 패킷의 손실로 TIME_OUT이 발생한 경우
 - 확인된 마지막 프레임 이후로 모든 프레임을 재전송한다
 - 슬라이딩 윈도우는 연속적인 프레임 전송기법이다
 - 전송측은 전송된 모든 프레임의 복사본을 가지고 있어야 하며, ACK와 NAK 모두 구별해야 한다

＊ 재전송 되는 경우
☞ NAK 프레임을 받았을 경우
☞ 전송 데이터 프레임의 분실
☞ 지정된 타임아웃 내의 ACK 프레임 분실 (Lost ACK)

### 혼잡 제어

 - 송신측의 데이터 전달과 네트워크의 데이터 처리 속도를 해결하기 위한 기법
 - 한 라우터에게 데이터가 몰려 모든 데이터를 처리할 수 없는 경우, 호스트들은 재전송을 하게 되고 혼잡이 가중되어 오버플로우, 데이터 손실이 발생한다
 - 네트워크 혼잡을 피하기 위해 송신측에서 보내는 데이터의 전송 속도를 제어하는 것이 혼잡 제어이다

![image](https://user-images.githubusercontent.com/97201374/185394604-a3158a79-9404-4994-b516-315894772a44.png)



1, AIMD (Additive Increase / Multiplicative Decrese)
 - 처음 패킷을 하나씩 보내고 문제없이 도착할 경우 window 크기를 1씩 증가시키며 전송
 - 패킷 전송에 실패하거나 일정 시간 초과시 패킷 전송 속도를 절반으로 줄임
 - 이는 공평한 방식으로 시간이 지나면 평형상태로 수렴하게 된다
 - 문제점은 초기에 네트워크의 높은 대역폭을 사용하지 못하여 오랜 시간이 걸리고, 혼잡해지는 상황을 미리 감지하지 못한다
 - 네트워크가 혼잡해지고 나서야 대역폭을 줄이는 방식

2. Slow Start
 - AIMD 방식의 오래 걸리는 단점을 보완
 - 처음 패킷을 하나씩 보내고 문제없이 도착할 경우 ACK 패킷마다 window 크기를 1씩 증가
 - 한 주기가 지나면 window 크기가 2배가 된다
 - 전송 속도는 AIMD에 비해 지수함수꼴로 증가
 - 혼잡 현상이 발생할 경우 window 크기를 1로 떨어뜨린다
 - 처음 네트워크 수용량을 예상할 수 있는 정보는 없지만, 한번 혼잡 현상을 Rur을 후 네트워크의 수용량을 예상할 수 있다
 - 혼잡 현상이 발생한 window 크기의 절반까지 지수함수로 증가시키고
 - 절반이 지난 후부터 1씩 증가시킨다

3. Fast Retransmit
 - 패킷을 받는 쪽에서 먼저 도착해야 할 패킷이 도착하지 않음
 - 다음 패킷이 먼저 도착한 경우 ACK 패킷을 보내게 된다
 - 단, 순서대로 잘 도착한 마지막 패킷이 다음 패킷의 순번을 ACK 패킷에 실어서 보내게 되므로, 중간에 하나가 손실되게 되면 송신 측에서는 순번이 중복되어 ACK 패킷을 받게 된다
 - 이를 감지하는 순간 문제가 되는 순번의 패킷을 재전송
 - 중복된 순번의 패킷을 3개 받으면 재전송을 하게 된다
 - 혼잡을 감지하고 window 크기를 줄인다

4. Fast Recovery
 - 혼잡한 상태가 되면 window 크기를 줄이지 않고, 반으로 줄이고 선형증가시키는 방법
 - 혼잡 상황을 한번 겪은 후 AIMD 방식으로 동작

## UDP (User Datagram Protocol)

 데이터를 데이터그램 단위로 처리하는 프로토콜로 비연결형, 신뢰성이 없는 전송 프로토콜이다
 데이터그램 단위로 쪼개면서 전송하기 때문에 전송 계층에 포함된다

 - UDP의 결정적 장점은 데이터의 신속성 (TCP보다 데이터 처리 속도가 빠르다)
 - 실시간 방송, 온라인 게임에서 사용되며, 네트워크 환경이 불안정할 경우 끊김 현상도 발생한다


### TCP와 UDP가 나오게 된 배경

 1. IP의 역할은 Host to Host만을 지원하는데, 장치에서 장치로 이동은 IP로 해결되지만, 하나의 장비 안에서 수 많은 프로그램들이 통신할 경우 IP만으로 한계에 봉착
 2. IP에서 오류가 발생시 ICMP에서 달려준다. but, 알려주기만 할 뿐 대처를 하지 못해 IP보다 위에서 이를 처리해줘야 함

ICMP : 인터넷 제어 메시지 프로토콜로 네트워크 컴퓨터 위에서 돌아가는 운영체제에서 오류 메시지를 전송받는 역할을 함

☞ 1번 문제 해결을 위해 포트번호가 만들어짐
☞ 2번 문제를 해결하기 위해 상위 프로토콜인 TCP와 UDP가 만들어짐


### TCP와 UDP의 오류 해결법

☞ TCP
 - 데이터의 분실, 중복, 순서 뒤바뀜 등을 자동으로 보정해준다
 - 송수신 데이터의 정확한 전달을 도와줌

☞ UDP
 - IP가 제공하는 정도의 수준만을 제공하는 간단한 IP 상위 계층 프로토콜이다
 - TCP와 다르게 에러가 발생할 수 있다
 - 재전송이나 순서가 뒤바뀔 수도 있다
 - 이러한 경우에 애플리케이션에서 처리하는 번거로움도 존재한다

☞ DNS 환경에서 UDP를 사용하는 이유
 - Request 양이 작다 → UDP Request에 담을 수 있다
 - 3-Way handshaking으로 연결을 유지할 필요가 없다 (오버헤드 발생)
 - Request에 대한 손실은 Application Layer에서 제어가 가능
 - DNS : port 53번
 - 크기가 512가 넘는 경우 TCP를 사용
 - UDP는 512가 넘는 경우 사용이 불가능하다 (크기 제한)

1. TCP가 3-Way handshake를 사용하는 반면, UDP는 connection을 유지할 필요가 없음
2. DNS request는 UDP segment에 꼭 들어갈 정도로 작음
3. UDP는 Timeout 추가나 resend 작업을 통해 application layer에 추가될 수 있음


## HTTP

 웹 상에서 웹 서버 및 웹 브라우저 상호 간 데이터 전송을 위한 응용계층 프로토콜
- 처음에는 WWW 상의 하이퍼텍스트 형태의 문서 전달하는데 주로 이용
- 현재에는 이미지, 비디오, 음성 등 모든 형태의 데이터 전송이 가능

특징 : 요청 및 응답 메시지로 대응되는 구조
 - 동작 형태가 Client-Server 모델로 동작
![image](https://user-images.githubusercontent.com/97201374/185394649-dc389eca-2c2e-4196-960a-92312be3111e.png)


	: 메시지 교환 형태의 프로토콜
 - 클라이언트와 서버 간에 ‘HTTP 메시지’를 주고받으며 통신
 - SMTP 전자메일 프로토콜과 유사
	: 트랜잭션 중심의 비연결성 프로토콜
 - 종단간 연결이 없다 (Connectionless _ 비연결 지향)
	: 클라이언트가 서버에 요청시, 그 요청에 맞는 응답을 보낸 후 연결을 끊는 처리
 - 이전 상태를 유지하지 않는다 (Stateless)
	: 커넥션을 끊는 순간 클라이언트와 서버 통신이 끝나며 상태 정보를 유지하지 않음
	 - 클라이언트와 첫 통신에서 데이터를 주고받았다 하더라도
	 - 두 번째 통신에서 이전 데이터를 유지하지 않는다
	 - 하지만, 실제로 데이터 유지가 필요한 경우가 있다
	 → 따라서, stateful 경우를 대처하기 위해 쿠키와 세션을 이용
		쿠키와 세션의 차이점은 크게 상태 정보의 저장 위치이다
		쿠키는 ‘Client’에 저장 / 세션은 ‘Server’에 저장

### HTTP의 인증, 보안
☞ HTTP 인증 방식
 - 자체 인증 방식 : Basic 인증 및 Digest 인증
 - 기타 인증 방식 : 별도의 인증 모듈을 사용하여 직접 구현 (복잡하지만 보안성 강화)

☞ HTTP 보안 버전 : HHTPS (Secure Hypertext Transfer Protocol)
 - 도청, 통신 상대방 위장
 - 임의 내용 변경 등 방지
 - SSL / TLS 등 다른 프로토콜들을 조합시켜 통신 내용을 암호화시킴

### HTTP의 중계
☞ 프록시 (Proxy)
 - 역할 : 다른 사람을 대신하여 무언가 하는 중개자 역할
 - 위치 : Client와 Server 사이에 위치
 - 특징 : 동일 프로토콜로 연결
 - 용도 : 캐싱, 영역 내 특정 웹사이트 접근 방지, 엑세스 로그 획등 등

☞ 게이트웨이 (Gateway)
 - 역할 : 프록시처럼 중계 역할을 하나, HTTP 프로토콜 이외의 기능 수행 (프로토콜 변환)
 - 특징 : 서로다른 프로토콜 간 변화해주며 연결
 - 참고 : CGI

☞ 릴레이 : 단순 프록시 (단순 중계)

## HTTP의 버전 표준 / 역사
☞ HTTP 0.9 : 정식 버전과 구분을 위해 HTTP/0.9라고도 부름 (1990년)
 * HTML 문서를 요청해 이를 가져오는 매우 단순한 초기의 프로토콜
 - 단일 라인 요청에 경로 제시
 - GET 메서드로써 문서를 가져오고 연결을 끊는 일을 수행
 - 요청에 데이터(바디)를 포함하지 않음

☞ HTTP 1.0 : RFC 1945 (1996년)
 * 유용한 초기 개념들을 도입
 - HTTP 헤더 (요청, 응답 모두에 사용 / 헤더, 바디를 빈 줄로 분리)
 - HTTP 메서드
 - HTTP 응답 코드
 - 리다이렉트, 비지속 연결(non-presistent) 등

☞ HTTP 1.1 : RFC 2068 (1997년) → RFC 2616 (1999년) → RFC 7239~7235 (1998년 ~)
 * HTTP 1.0으로부터 기능 향상
 - HTTP 헤더 내 Host 필드를 필수 항목으로 함
	- 1개 IP 주소에 다수의 가상 호스팅이 가능
 - HTTP 헤더 내 Accept 필드에 의한 컨텐츠 협상
 - HTTP 메서드 추가 및 조정
	- OPTIONS, CONNECT, TRACE 추가
	- PUT, DELETE 필수로 됨
 - 잘 정의된 캐시 컨트롤
 - 블록 단위 인코딩 전송
 - 병렬 커넥션
	- HTTP 1.0에서는 요청 헤더에 다음 헤더를 추가함으로
	- Keep-Alive로 구현되었으나
	- HTTP 1.1부터는 지속 커넥션 접속이 기본 동작이 됨
	- 기존 TCP 연결을 끊지 않음으로, 재연결에 따른 TCP 느린 시작에 의한 지연 방지
 - 크기를 미리 알 수 없는 컨텐츠의 청크(chuncked) 전송 인코딩 지원
 - SSL / TLS에 의한 암호화 통신 지원

## HTTPS

 HTTP는 브라우저와 서버 사이에서 정보를 평문으로 전송하므로 정보가 전달되는 네트워크에서 정보를 엿볼 수 있다
 → 이러한 문제를 해결하기 위해 HTTPS가 소개 (S : Secure)
1. 클라이언트와 서버가 암호화 통신 채널을 설정
2. 평문 HTTP 메시지를 전송
3. 정보유출을 막음

### 암호화 채널이란?

 암호화 채널은 이전에 SSL (Secure Socket Layer)이라 불렸던 TLS (Transpoert Layer Security) 프로토콜을 사용해서 만든다
 흔히 SSL과 TLS를 혼용했으나 현재는 TLS 1.0으로 대체
 현재 IETF 표준인 TLS 버전 (1.0, 1.1, 1.2)을 사용하며 SSL은 보안 문제로 거의 사용하지 않으며, 경고 표시를 띄운다

 1996~97년 사이에 현재의 안정적인 인터넷 버전 HTTP 1.1이 등장했으며, 대부분의 웹사이트가 이 버전에서 운영되고 있다

 HTTP는 민감하지 않은 트래픽에 이용되며, HTTPS는 민감한 트래픽 (인증, 전자상거래)에 이용된다.
 현재 프라이버시에 관심이 높아지면서 웹 브라우저에서 HTTP 웹사이트를 ‘안전하지 않음’으로 표시하고 HTTP에 경고를 보내고 있다

### HTTP에서 제공하는 3가지
☞ 기밀성 : HTTPS는 인터넷과 같은 공공 매체에서 두 참여자 간의 통신을 보호한다
 - HTTPS가 없다면 Wi-Fi를 이용하는 사람은 개인정보를 다른 사람이 볼 수 있다

☞ 무결성 : HTTPS는 변조되지 않은 정보로 목적지에 도달하게 한다
 - Wi-Fi가 웹사이트에 광고 추가, 이미지 품질 저하, 내용 변조를 할 수 있다
 - HTTPS는 웹사이트를 변조할 수 없도록 한다

☞ 인증 : HTTPS를 통해 웹사이트의 진위 여부를 확인할 수 있다
 - 가짜 웹사이트를 브라우저에 띄울 수 있다
 - HTTPS는 이 웹사이트가 실존하는지 확인한다



### HTTPS 인증서 유형

1. 신원 검증

☞ DV (Domain validated) : DV 인증서는 도메인이 특정 공개 키와 일치하는지 확인
 - 브라우저는 서버와 보안 연결을 수립하고 닫힌 자물쇠를 표시
 - 자물쇠 표시를 클릭하면 ‘현재 웹사이트는 소유자 정보를 제공하지 않고 있습니다’를 표시
 - 도메인 외의 다른 특별한 요구사항은 없음

☞ EV (Extended validation) : EV 인증서는 웹사이트의 법적 신분을 검증한다
 - EV 인증서는 가장 신뢰할 수 있는 유형의 인증서
 - 인증 기관에서 도메인을 관리하는 이의 법적 신원을 확인한 후 얻을 수 있다
 - 법적 신원 얻는 방법
	- 도메인 관리 (Ex : DV 인증서)
	- 회사가 등록되었고 현재 유지 상태인지 확인할 수 있는 공인된 사업 기록
	- D&B (Dunn & bradstreet), 세일즈포스 connect.data.com, 전화번호부 등에 등재된 자영업 정보
	- 확인 전화
	- 인증서의 모든 도메인 이름
	- iOS 사파리와 같은 일부 기기는 검증된 신원만 표시하고, 전체 URL 무시
 ☞ OV (Organization validated) : EV처럼 OV 인증서는 웹사이트의 법적 신분을 검증
 - EV 인증서와 달리 OV HTTPS 인증서에는 UI에서 확인된 법적 이름을 표시 x
 - OV 인증서는 높은 검증 요구 사항 대비 이점이 없기 때문에 인기가 덜함

2. 다루는 도메인 수

☞ 이전 HTTPS 인증서는 일반적으로 CN 필드에서 하나의 도메인을 다뤘다
☞ 요즘 만드는 모든 HTTPS 인증서는 동일하다 

3. 구성

☞ HTTPS의 네 가지 구성요소는 다음의 암호화를 필요로 한다
 - 초기 키 교환 비대칭 (개인키와 공개키) 알고리즘을 사용한다
 - 신원 인증서 (인증 기관에서 발행한 HTTPS 인증서) 이 인증서는 비대칭 알고리즘을 사용
 - 실제 메시지 암호화 대칭 (미리 공유한 시크릿) 알고리즘을 사용
 - 메시지 다이제스트 암호 해싱 알고리즘을 사용

4. 키 유형

☞ ECC (Elliptic Curve Cryptography)
 - RSA 인증서보다 더 빠르고 CPU를 덜 사용하는데, 모바일 클라이언트에는 이런 점이 중요
 - 아마존 클라우드프론트, 헤로쿠와 같은 일부 서비스는 ECC 인증서를 지원하지 않음
 - 256비트 ECC키면 충분
☞ RSA (Rivest Shamir Adleman)
 - 더 느리지만 오래된 다양한 서버와 호환된다
 - 2048비트 RSA키가 최소한이다
 - 4096비트 이상의 RSA 키는 성능에 좋지 않다
 - RSA 인증서는 2048비트 중간 인증 기관에서 서명할 수도 있어 추가적인 보안에 손상을 준다

### HTTPS 인증서를 얻으려면 거쳐야 하는 단계

1. 개인키와 공개키 쌍을 만들고 조직과 공개키에 관한 정보를 포함하는 CSR(Certificate Singning Request)을 준비한다
2. 인증 기관에 연결해 CSR 기반 HTTPS 인증서를 요청한다
3. 서명된 HTTPS 인증서를 획득하고 웹 서버에 인증서를 설치한다


## HTTPS와 handshake 전송기술
 - TCP, UDP와 같은 일반적인 인터넷 통신에 안전한 계층(Layer)을 추가하는 방식
 - 이 기술을 구현하기 위해 웹 서버에 설치하는 것이 SSL / TLS 인증서이다
 - TLS는 SSL의 개선 버전으로, 최신 인증서는 TLS를 사용하지만 편의적으로 SSL 인증서라고 부름

☞ SSL (Secure Socket Layer)
☞ TLS (Transport Layer Security)

☞ SSL 인증서와 SSL handshake에 탑재된 보안 기술
 - 하나의 키로 암호화 / 복호화를 수행하는 대칭키 암호화 방식
 - 한 쌍의 키 페어로 암호화 / 복호화를 수행하는 비대칭키 암호화 방식
 - 통신 대상을 서로가 확인하는 신분 확인 (authentication)
 - 믿을 수 있는 SSL 인증서를 위한 디지털 서명 (digital signature)
 - 디지털 서명을 해주는 인증 기관 (CA : Certificate Authority)
 - 공개키를 안전하게 전달하고 공유하기 위한 프로토콜
 - 암호화된 메시지의 변조 여부를 확인하는 메시지 무결성 알고리즘

 * 대칭키 암호화 방식 (symmetric-key algorithm)
 - 하나의 키로 평문을 암호화
 - 다시 암호문을 원해의 평문으로 복호화하는 방식
 - 키를 단 하나만 사용하는 간편함이 있다
 - but, 키를 분실, 도난당할 경우에 내 암호문을 누군가 복호화 할 수 있다는 단점 존재

![image](https://user-images.githubusercontent.com/97201374/185394782-1d233588-c663-4f2c-a649-adcc50eff77c.png)



 * 공개키 암호화 방식 (= 비대칭키 암호화 방식)
 - 공개키, 개인키 두 개의 키를 한 쌍으로 각각 암호화 / 복호화에 사용
 - 공개키로 암호화한 것을 개인키로 복호화
 - 개인키를 먼저 만들고 여기에 공개키를 파생하여 한 쌍의 키를 만든다 (key pair)
 - 같은 쌍이 아닌 다른 키를 사용하려 한다면 암호화 / 복호화가 불가능
 - 공개키는 누구에게나 공개할 수 있는 키
 - 공개키 암호화 방식은 사전에 안전하게 서로의 공개키를 나누어 받는 과정이 필요
 - 짝에 해당하는 개인키 없이 복호화가 불가능하기 때문에 불안해 할 필요가 없음
 - 개인키는 안전하게 보관되어야 함
 - 대칭키에 비해 안전하지만, 계산 과정이 복잡하고 연산 도중 컴퓨터의 자원이 많이 발생

![image](https://user-images.githubusercontent.com/97201374/185394798-39f24ff9-1f7e-45db-a857-c4043cacfa41.png)


 이 때, 사용하는 대표적인 키 알고리즘으로 RSA (Rivest-Shamir-Adleman), 디피-할만 (Diffie-Hellman) 알고리즘이 있다


## SSL 핸드 쉐이크 과정
 - 통신을 하는 브라우저와 웹 서버가 서로 암호화 통신을 시작할 수 있도록 신분을 확인하고, 필요한 정보를 클라이언트와 서버가 주거니 받거니 하는 과정이 이름 붙여진 것
![image](https://user-images.githubusercontent.com/97201374/185394823-63c0e9ad-4f7f-41a5-8a34-0dff49a4822b.png)


Client ① 클라이언트가 먼저 서버에 접속해 말을 건다
 - 브라우저가 사용하는 SSL 혹은 TLS 버전 정보
 - 브라우저가 지원하는 암호화 방식 모음(cipher suite)
	cipher suite : 보안의 궁극적 목표 달성을 위해 사용하는 방식을 패키지화 한 것
	 - 안전한 키 교환
	 - 전달 대상 인증
	 - 암호화 알고리즘
 	 - 메시지 무결성 확인 알고리즘
 - 브라우저가 순간적으로 생성한 임의의 난수
 - 만약 이전에 SSL핸드 쉐이크가 완료된 상태라면, 그 때 생성된 세션 아이디
 - 기타 확장 정보 (extension)

Server ② 서버 또한 위의 인사에 응답하며 다음 정보를 클라이언트에 제공
 - 브라우저의 암호화 방식 정보 중 서버가 지원하고 선택한 암호화 방식 (cipher suite)
 - 서버의 공개키가 담기 SSL 인증서 (인증서는 CA의 비밀키로 암호화 된 상태)
 - 서버가 순간적으로 생성한 임의의 난수
 - 클라이언트 인증서 요청 (선택사항)

Client ③ 브라우저는 서버의 SSL 인증서가 믿을만한지 확인
 - 대부분의 브라우저에는 공신력 있는 CA의 정보와 공개키가 이미 설치되어있음
 - 서버가 보낸 SSL 인증서가 정말 CA가 만든 것인지 확인하기 위해
 - 내장된 CA 공개키로 암호화된 인증서를 복호화
 - 정상적인 복호화가 이루어진다면 CA가 발급한 것이 증명

Client ④ 브라우저는 자신이 생성한 난수와 서버의 난수를 사용하여 premaster secret 만듦
 - 웹 서버 인증서에 딸려온 웹사이트의 공개키로 이것을 암호화하여 서버로 전송

Server ⑤ 서버는 사이트의 비밀키로 브라우저가 보낸 premaster secret 값을 복호화
 - 복호화 한 값을 master secret 값으로 저장
 - 고유한 값을 부여하기 위한 session key를 생성
 - 세션키는 대칭키 암호화에 사용할 키
 - 세션키를 이용하여 브라우저와 서버 사이에 주고받는 데이터를 암호화하고 복호화 한다

Server / Client ⑥ SSL handshke를 종료하고 HHTPS 통신을 시작


### HTTPS를 적용하면 100% 안전?
 - HTTPS는 웹에서 보안을 적용하기 위한 가장 기본적인 단계이다
 - 이것만으로 모든 보안성이 완벽하다고 할 수 없다


## GET 방식과 POST 방식

 브라우저가 서버에 요청하는 것

☞ GET 방식
 - 요청을 전송할 때 필요한 데이터를 body에 담지 않고 쿼리스트링을 통해 전송
 - URL 끝에 ? 와 함께 이름과 값으로 쌍을 이루는 요청 파라미터를 쿼리스트링이라 함
 - 요청 파라미터가 여러개면 &로 연결
 - 쿼리스트링을 사용하면 URL에 조회 조건을 표시하기 때문에 특정 페이지를 링크, 북마크 할 수 있다
 
 - GET은 불필요한 요청을 제한하기 위해 요청이 캐시될 수 있다
 - js, css, 이미지 같은 정적 컨텐츠는 데이터양이 크고 변경될 일이 적어 반복해서 동일 요청을 보낼 필요가 없다
 - 정적 컨텐츠를 요청하고 나면 브라우저에서는 요청을 캐시해둔다
 - 동일한 요청이 발생할 경우 서버로 요청을 보내지 않고 캐시 데이터를 사용

< 정리 >
 - GET 요청은 캐시가 가능하다
 - GET을 통해 서버에 리소스를 요청할 때 웹 캐시가 요청을 가로채 서버로부터 리소스를 다시 다운로드하는 대신 리소스의 복사본을 반환
 - HTTP 헤더에서 cache-control 헤더를 통해 캐시 옵션을 지정할 수 있다
 - GET 요청은 브라우저 히스토리에 남는다
 - GET 요청은 길이 제한이 있다
 - GET 요청은 중요한 정보를 다루면 안된다

☞ POST 방식
 - 리소스를 생성 / 변경하기 위해 설계
 - GET과 달리 전송해야 할 데이터를 HTTP 메시지의 body에 담아서 전송
 - body는 길이 제한이 없어 데이터를 전송할 수 있다
 - POST 요청은 대용량 데이터 전송이 가능
 - POST 요청도 크롬 개발자 도구, Fiddler와 같은 툴로 요청 내용을 확인할 수 있어 민감한 데이터의 경우 반드시 암호화가 필요
 - POST 요청을 보낼 때 요청 헤더의 Content-Type에 요청 데이터 타입을 표시해야 한다
	- 데이터 타입 종류
	application/x-www-form-urlencoded
	text/plain
	multipart/form-data

< 정리 >
 - POST 요청은 캐시되지 않는다
 - POST 요청은 브라우저 히스토리에 남지 않는다
 - POST 요청은 데이터 길이에 제한이 없다

## GET과 POST의 차이점

☞ 사용 목적
 - GET : 서버의 리소스에서 데이터를 요청할 때
 - POST : 서버의 리소스를 새로 생성하거나 업데이트 할 때
 - DB로 따지면 GET은 SELECT / POST는 CREATE에 가깝다

☞ 요청에 body 유무
 - GET : URL 파라미터에 요청하는 데이터를 담아 보내기 때문에 HTTP 메시지에 body가 없다
 - POST : body에 데이터를 담아보낸다

☞ 멱등성
 - GET : 멱등이다
 - POST : 멱등이 아니다

 * 멱등
 - 연산을 여러 번 적용하더라도 결과가 달라지지 않는 성질
 - GET : 리소스를 조회한다는 점에서 여러 번 요청하더라도 응답이 같다
 - POST : 리소스를 새로 생성하거나 업데이트할 때, 사용되기 때문에 멱등이 아니다
 ( POST 요청이 발생하면 서버가 변경될 수 있다 )


## 쿠키와 세션

### 쿠키 (Cookie)
 - HTTP의 일종으로 사용자가 웹사이트를 방문할 경우
 - 그 사이트가 사용하고 있는 서버에서 사용자의 컴퓨터에 저장하는 기록 정보 파일이다
 - HTTP에서 Client 상태 정보를 PC에 저장했다가, 필요 시 참조하거나 재사용
![image](https://user-images.githubusercontent.com/97201374/185394858-96c22f01-dae1-470a-83a4-9499e362eb96.png)

- 쿠키 발급과 사용하는 과정

특징 : 이름, 값, 만료일(저장기간), 경로 정보로 구성
	클라이언트에 총 300개의 쿠키를 저장할 수 있다
	하나의 도메인 당 20개의 쿠키를 가질 수 있다
	하나의 쿠키는 4KB(= 4096byer)까지 저장 가능

☞ 쿠키 동작 순서
 - 클라이언트가 페이지를 요청 (사용자가 웹사이트 접근)
 - 웹 서버는 쿠키를 생성
 - 생성한 쿠키에 정보를 담아 HTTP 화면을 돌려줄 때, 같이 클라이언트에게 돌려줌
 - 넘겨받은 쿠키는 클라이언트가 가지고 있음
 - 서버에 요청할 때, 요청과 함께 쿠키를 전송
 - 동일 사이트 재방문 시 클라이언트에 쿠키가 있는 경우, 요청 페이지와 함께 전송

### 세션 (Session)
 - 일정 시간 동안 같은 사용자로부터 들어오는 일련의 요구를 하나의 상태로 봄
 - 그 상태를 유지시키는 기술
 - 방문자가 웹 서버에 접속해있는 상태를 하나의 단위로 보고 그것을 세션이라 함

특징 : 웹 서버에 웹 컨테이너 상태를 유지하기 위한 정보를 저장
	웹 서버에 저장되는 쿠키 (= 세션 쿠키)
	브라우저를 닫거나, 서버에서 세션을 삭제했을 때만 삭제가 됨
	쿠키보다 보안이 좋다
	저장 데이터에 제한이 없음 (서버 용량이 허용하는 선에서)
	각 클라이언트에 고유 Session ID를 부여
	Session ID로 클라이언트를 구분, 각 요구에 맞는 서비스를 제공

☞ 세션 동작 순서
 - 클라이언트가 페이지에 요청 (사용자가 웹사이트 접근)
 - 서버는 접근한 클라이언트의 Request-Header 필드인 Cooke를 확인
 - 클라이언트가 해당 session-id를 보냈는지 확인
 - session-id가 존재하지 않으면 서버는 id를 생성해 클라이언트에게 돌려줌
 - 서버에서 클라이언트로 돌려준 session-id를 쿠키를 사용해 서버에 저장
 - 클라이언트는 재접속 시, 이 쿠키를 이용해 session-id 값을 서버에 전달


### 쿠키와 세션의 차이
 - 쿠키와 세션은 비슷한 역할을 하며, 동작 원리도 비슷 (세션도 쿠키를 사용하기 때문)
 - 큰 차이점은 사용자의 정보가 저장되는 위치
	쿠키 : 서버의 자원을 전혀 사용하지 않음
	세션 : 서버의 자원을 사용
 - 보안은 세션이 더 우수하다
 - 쿠키는 클라이언트 로컬에 저장되기 때문에 변질되거나 request에서 스니핑 당할 우려가 있어 보안에 취약
 - 세션은 쿠키를 이용해 session-id만 저장하고 그것으로 구분하여 서버에 처리하기 때무에 보안성이 높음
 - 만료기간을 따로 지정해 쿠키를 삭제할 때까지 라이프 사이클을 유지할 수 있다
 - 세션도 만료기간을 정할 수 있지만, 브라우저 종료시 만료기간에 상관없이 삭제
 - 쿠키에 정보를 담기 때문에 요청 시 속도가 빠름
 - 세션을 정보가 서버에 있어 요청 시 비교적 느린 속도를 낸다

 * 라이프 사이클 (만료 기간)
 - 쿠키는 설정을 해두면 브라우저를 종료해도 유지
 - 세션은 브라우저의 종료와 함께 삭제


## REST , REST API , RESTful API

### REST (REpresentational State Transfer)
 - 자원을 이름으로 구분해 해당 자원의 정보를 주고받는 모든 것
 - 자원(resource)의 표현(representation)에 의한 상태 전달
	- 자원 : 해당 소프트웨어가 관리하는 모든 것
	- 표현 : 그 자원을 표현하기 위한 이름
	- 상태 전달 : 데이터가 요청되는 시점에 자원의 상태를 전달 (JSON, XML을 통함)

 - 기본적으로 웹의 기존 기술과 HTTP 프로토콜을 그대로 활용
 - 웹의 장점을 최대한 활용할 수 있는 아키텍처 스타일
 - REST는 네트워크 상에서 Client와 Server 사이 통신 방식 중 하나이다

 - 자원에 대해 (Create, Read, Update, Delete) 연산을 수행하기 위해 URI로 GET, POST 방식을 사용하여 요청
 - 요청을 위한 자원은 특정한 형태 (Representation of Resource)로 표현

### REST의 구성 요소

☞ 자원 (Resource) - URI
 - 모든 자원에는 고유한 ID가 존재, 자원은 Server에 존재
 - 자원을 구별하는 ID는 ‘/exgroups/:exgroup_id’와 같은 HTTP URI
 - Client는 URI를 이용해 자원을 지정, 해당 자원의 정보에 대한 조작을 Server에 요청

☞ 행위 – Method
 - HTTP 프로토콜의 Method를 사용
 - HTTP 프로토콜은 다음과 같은 Method를 제공
![image](https://user-images.githubusercontent.com/97201374/185394897-45d881f6-3aba-4e87-a45c-36158a2933fe.png)


☞ 표현 (Representation of Resource)
 - Clinet와 Server가 데이터를 주고받는 형태로 JSON, XML, TEXT, RSS 등이 있다
 - JSON, XML을 통해 데이터를 주고 받는 것이 일반적

### REST의 특징

☞ Server-Client 구조
 - 자원이 있는 쪽이 Server, 자원을 요청하는 쪽이 Client

☞ Stateless (무상태)
 - HTTP 프로토콜은 Stateless Protocol이므로 REST 역시 무상태성을 갖는다
 - Client의 context를 Server에 저장하지 안흔ㄴ다
 - Server는 각각의 요청을 완전히 별개의 것으로 인식하고 처리

☞ Cacheable (캐시 처리 기능)
 - 웹 표준 HTTP 프로토콜을 그대로 사용하므로 웹에서 사용하는 기존의 인프라를 그대로 활용할 수 있다
 - 대량의 요청을 효율적으로 처리

☞ Layered System (계층 구조)
 - Client는 REST API Server만 호출
 - REST Server는 다중 계층으로 구성될 수 있다

☞ Uniform Interface (인터페이스의 일관성)
 - URI로 지정한 Resource에 대한 요청을 통일되고, 한정적으로 수행하는 아키텍처 스타일
 - HTTP 표준 프로토콜에 따르는 모든 플랫폼에서 사용가능
 - Loosely Coupling(느슨한 결합) 형태를 갖는다

☞ Self-Descriptiveness (자체 표현)
 - 요청 메시지만 보고도 쉽게 이해할 수 있는 자체 표현 구조


### REST API

 - REST의 특징을 기반으로 서비스 API를 구현한 것
 - 최근 OpenAPI, 마이크로 서비스 등을 제공하는 기업들이 REST API를 제공

### REST API의 특징

☞ 각 요청이 어떤 동작이나 정보를 위한 것인지 그 요청의 모습 자체로 추론이 가능

### 디자인 가이드 2가지

☞ URI는 정보의 자원을 표현해야 한다
☞ 자원에 대한 행위는 HTTP Method로 표현한다
 - 행위 (Method)는 URI에 포함하지 않는다


### REST API와 RESTful API의 차이?
 - RESTful은 REST의 설계 규칙을 잘 지켜서 설계된 API를 RESTful한 API라고 함
 - REST의 원리를 잘 따르는 시스템을 RESTful이란 용어로 지칭
 - RESTful하게 만든 API는 요청을 보내는 주소만으로도 어떤 것을 요청하는지 파악이 가능

☞ REST API?
 - URI는 정보의 자원만 표현해야 하며, 자원의 행위는 HTTP Method에 명시한다는 것


## DNS(Domain Name System)란?
![image](https://user-images.githubusercontent.com/97201374/185394928-05a38235-c382-4f1c-a044-59d0d67ba6a2.png)

 - 웹사이트에 접속할 때, 외우기 어려운 IP 주소 대신 도메인 이름을 사용
 - 도메인 이름을 사용했을 때, 입력한 도메인을 실제 네트워크상에서 사용하는 IP 주소로 바꾸고 해당 IP 주소로 접속하는 과정이 필요
 - 이러한 과정, 전체 시스템을 DNS라고 한다
 - 이러한 시스템은 전세계적으로 약속된 규칙을 공유
 - 상위 기관에서 인증된 기관에 도메인을 생성하거나 IP 주소로 변경할 수 있는 ‘권한’ 부여
 -  DNS는 이처럼 상위, 하위 기관을 갖는 ‘계층 구조’를 가진 분산 DB 구조를 가진다

### DNS 구성 요소

☞ 도메인 네임 스페이스 (Domain Name Space)
☞ 네임 서버(Name Server) = 권한 있는 DNS 서버
☞ 리졸버(Resolver) = 권한 없는 DNS 서버

 - “도메인 이름에 IP 주소”라는 “텍스트”를 저장하는 데이터베이스가 필요
 - 분산된 데이터가 어디 저장되어있는지 찾을 프로그램이 필요하고 해당 IP주소로 이동할 브라우저가 필요
 - 도메인 네임 스페이스라는 규칙으로 도메인 이름 저장을 분산
 - 네임서버가 해당 도메인 이름의 IP 주소를 찾는다
 - 리졸버가 DNS 클라이언트 요청을 네임 서버로 전달하고 찾은 정보를 클라이언트에게 제공하는 기능을 수행
 - 어떤 네임 서버에서 찾아야하는지, 이미 캐시되어있는지 등 찾아서 전달하는 역할을 함
 - 리졸버는 단말에 구현하는 것은 무리수라 보통은 리졸버가 구현된 네임 서버의 IP 주소만을 파악
 - 대표적으로 KT / LG / SK와 같은 ISP(통신사) DNS가 있고, 브러우저 우회 용도로 많이 사용하는 구글 운, 클라우드플레어와 같은 Public DNS 서버가 있다
 - Resolver = Recursive DNS Server = Local Server(of ISP) = Recursor


## DNS 구성 요소 : 도메인 네임 스페이스 
![image](https://user-images.githubusercontent.com/97201374/185395103-b0b07eeb-7400-4f84-8ab4-a100233c6ca9.png)


 - DNS는 전세계적 거대한 분산 시스템
 - 도메인 네임 스페이스는 이러한 DNS가 저장 관리하는 계층적 구조를 의미
 - 도메인 네임 스페이스는 최상위 루트 DNS 서버가 존재하고 그 하위로 연결된 모든 노드가 연속해서 이어진 계층 구조로 되어있다

## DNS 구성 요소 : 네임 서버

 - 문자열로 표현된 도메인 이름을 실제 컴퓨터가 사용하는 IP 주소로 변환시키기 위해 도메인 네임 스페이스의 트리 구조에 대한 정보가 필요한데
 - 이러한 정보를 가지고 있는 서버를 네임 서버라고 한다
 - 데이터베이스 역할(저장, 관리), 찾아주는 역할, 요청 처리 응답 구현
 - 전 세계 13개의 Root DNS 서버가 구축되어 있다
 - DNS 서버를 복사하여 같은 기능을 담당하는 미러 서버가 있다

☞ Root DNS 서버
 - ICANN이 직접 관리하는 절대 존엄 서버
 - TL.D DN.S 서버 IP주소를 저장하고 안내하는 역할을 함

☞ Top-Level Domain(TL.D) DN.S 서버
 - 도메인 등록 기관이 관리하는 서버
 - Authoritative DNS 서버의 주소를 저장하고 안내하는 역할을 한다

☞ Second-Level Domain(SLD) DN.S 서버
 - 실제 개인 도메인과 IP 주소의 관계가 기록(저장, 변경)되는 서버
 - 권한의 의미인 Authoritative가 붙음
 - 일반적으로 도메인 / 호스팅 업체의 네임 서버를 이야기한다
 - 개인 DNS를 구축해도 이에 해당

☞ 권한 없는 DN.S 서버 (리졸버, 리컬시브, 리커서)
 - DNS 서버는 도메인 네임 스페이스를 위한 권한 있는 DNS 서버와 권한 없는 DNS 서버로 구분
 - 네임 스페이스를 위한 권한 있는 DNS 서버는 IP 주소와 도메인 이름을 매핑
 - 네임 스페이스를 위한 권한 없는 DNS 서버는 질의를 통해 IP 주소를 알아내거나 캐시


### DN.S RoundRobin
 - DNS Server의 구성 방식 중 하나이다
 - Domain에 대한 IP 요청 쿼리시 RR 방식으로 IP를 반환
 - 시분할을 위한 선점형 스케줄링 중 한 방법인 RR은 프로세스에 우선순위를 두지 않고
 - 순서대로 시간단위로 CPU를 할당하는 방식의 스케줄링 알고리즘
 - 자동적으로 시간에 따라 스케줄링이 변화되기 때문에 로드밸런서가 필요없다

 * 로드밸런서 : 한 서버에 여러 요청이 들어오면 부하가 생기기 때문에, 동일 기능을 하는 서버들 중 여유로운 서버에 트래픽을 나누는 것
### Round Robin 문제점

☞ 서버의 수만큼 공인 IP 주소가 필요
 - DNS 서버에서 IP를 받기 때문

☞ 균등하게 분산되지 않음
 - 한 클라이언트의 요청당 다음 서버에게 요청이 되어 분산되는 것처럼 보이지만 , 다른 클라이언트들이 동시에 요청을 보낼 때 균등하게 트래픽을 분산시킨다고 가정하기 어렵다
 - 3번 서버에 문제가 생겨도 DNS는 이를 모르기 때문에 3번 서버의 IP를 알려준다
 - 서버가 다운되어도 확인이 불가능
 - DNS 결과를 캐싱하기 때문에 균등한 분산이 어렵다

### WRR (Weighted Round Robin)
 - 가중치를 정해주는 RR 방식
 - 서버별 가중치를 정해주고 이에 따라 분산해주는 방식
 - 서버의 성능이 높을수록 가중치를 높게 설정
 - 가중치가 큰 서버일수록 자주 선택된다

### Least Connection
 - 서버에 접속한 클라이언트 수가 가장 적은 서버를 선택, 알려주는 방식
 - 어떤 알고리즘을 사용할지 모를 경우에 사용

☞ WLC
 - LC와 같지만 가중치를 더한다
 - “(접속자 수 +1) / 가중치”가 최소가 되는 서버를 선택
 - 처리 능력이 높은 서버는 가중치를 크게 하는 것이 좋다

☞ SED (Shortest Expected Delay)
 - 가장 응답속도가 빠른 서버를 선택
 - 상태가 Established인 접속수가 가장 적은 서버를 선택
 - WLC와 거의 동일하지만, Established 이외의 상태인 접속수는 포함하지 않은다

☞ NQ (never queue)
 - SED와 동일한 알고리즘이지만, active 접속수가 0인 서버를 최우선으로 선택

☞ DH (Destination Hashing)
 - 목적지 IP 주소를 기반으로 해시값을 계산하여 분산대상 리얼서버를 선택

☞  LBLC (Locality-Based Least-Connection)
 - 접속자 수가 가중치로 지정한 값을 넘기기 전까지 동일한 서버를 선택
 - 접속자 수가 가중치를 넘어선 경우 다른 서버를 선택
 - 모든 서버의 접속자 수가 가중치를 넘을 경우 마지막에 선택된 서버가 계속 선택

☞ LBLCR (Locality-Based Least-Connection with Replication)
 - LBLC와 거의 같지만 모든 서버의 접속자 수가 가중치로 지정한 값을 넘을 경우 접속자 수가 가장 적은 서버가 선택


## 소켓 (Socket)
 - 프로세스가 데이터를 내보내거나 받기 위한 실제적 창구 역할
 - 프로세스가 데이터를 주거나 받기 위해서 반드시 소켓을 열어 내보내거나 읽어들여야 함
 - 떨어져 있는 두 호스트를 연결해주는 도구로 인터페이스 역할을 함
 - 데이터를 주고 받을 수 있는 구조체로 소켓을 통해 데이터 통로가 만들어짐
 - 서버 소켓, 클라이언트 소켓으로 구분

### 소켓은 어떻게 정의되고 나뉘어지는가?
☞ 프로토콜
 - 외교상의 언어로 의례나 국가간의 약속을 의미
 - 통신에서는 어떤 시스템이 다른 시스템과 통신을 원활하게 수용하도록 해주는 통신 규약, 약속을 의미

☞ IP
 -  전 세계 컴퓨터에 부여된 고유의 식별 주소

☞ 포트 (Port)
 -  네트워크 상에서 통신하기 위해서 호스트 내부적으로 프로세스가 할당받아야 하는 고유한 숫자
 - 한 호스트 내에서 네트워크 통신을 하고 있는 프로세스를 식별하기 위해 사용되는 값
 - 같은 호스트 내에서 서로 다른 프로세스가 같은 포트 넘버를 가질 수 없다
 - 같은 컴퓨터 내에서 프로그램을 식별하는 번호이다


### 소켓통신의 흐름
![image](https://user-images.githubusercontent.com/97201374/185395151-6194979b-9a5b-43ab-b147-fe5b9fb3e326.png)


☞ 서버 (Server)
클라이언트 소켓의 연결을 요청하고 대기, 연결 오청이 오면 클라이언트 소켓을 생성하여 통신이 가능하게 한다
 - socket( ) 함수를 이용하여 소켓을 생성
 - bind( ) 함수로 ip와 port 번호를 설정
 - listen( ) 함수로 클라이언트의 접근 요청에 수신 대기열을 만들어 몇 개의 클라이언트를 대기 시킬지 결정
 - accept( ) 함수를 이용하여 클라이언트와의 연결을 기다린다

☞ 클라이언트 (Client)
실제로 데이터 송수신이 일어나는 소켓
 - socket( ) 함수로 가장 먼저 소켓을 연다
 - connect( ) 함수를 이용하여 통신할 서버의 설정된 ip와 port 번호에 통신을 시도
 - 통신을 시도할 때, 서버가 accept( ) 함수를 이용하여 클라이언트의 socket descriptor를 반환
 - 이를 통해 클라이언트와 서버가 서로 read( ), write( )를 하며 통신
 - 그러한 읽고 쓰는 과정을 반복

### 소켓의 종류
☞ 스트림 (TCP)
 - 양방향으로 바이트 스트림을 전송, 연결 지향성
 - 오류 수정, 전송처리, 흐름제어 보장
 - 송신된 순서에 따라 중복되지 않게 데이터를 수신 → 오버헤드 발생
 - 소량의 데이터보다 대량의 데이터 전송에 적합 → TCP 사용

연결지향형인 TCP는 3-way handshaking 과정을 통해 연결 후 통신을 시작
또한, 흐름제어와 혼잡 제어를 지원하며 데이터 순서를 보장
UDP에 비해 속도가 다소 느리다
대부분의 웹 HTTP 통신, 이메일, 파일전송에 사용

☞ 데이터그램 (UDP)
 - 비연결형소켓
 - 데이터 크기 제한이 있다
 - 확실한 전달이 보장되지 않음
 - 데이터가 손실되어도 오류가 발생하지 않음
 - 실시간 멀티미디어 정보 처리를 위해 사용
ex) 전화, 방송, 영상통화

데이터그램 - UDP란?
전송계층의 비연결형 프로토콜
TCP와 다르게 연결 설정이 존재하지 않으며
혼잡제어를 하지 않기 때문에 TCP보다 빠르다는 장점을 지님
데이터 전송에 대한 보장을 하지 않기 때문에 패킷 손실이 발생할 수 있음
대부분 D.NS, 멀티미디어에 사용


☞ 흐름제어
 - 보내는 측과 받는 측 데이터 처리 속도 차이를 조절
☞ 혼잡제어
 - 네트워크 내의 패킷 수가 넘치게 증가하지 않도록 방지하는 것



### HTTP 통신과 SOCKET 통신의 비교

☞ HTTP 통신
 - Client의 요청(Request)이 있을 때만 서버가 응답(Response)
 - 해당 정보를 전송하고 곧바로 연결을 종료

특징
 - Client가 요청을 보내는 경우에만 Server가 응답하는 단방향 통신
 - Serer로부터 응답을 받은 후에는 연결이 바로 종료
 - 실시간 연결이 아니며, 필요한 경우에만 Server로 요청을 보내는 상황에 유용
 - 요청을 보내 Server의 응답을 기다리는 어플리케이션의 개발에 주로 사용

☞ SOCKET 통신
 - Server와 Client가 특정 Port를 통해 실시간으로 양방향 통신을 하는 방식

특징
 - Server와 Client가 계속 연결을 유지하는 양방향 통신이다
 - Server와 Client가 실시간으로 데이터를 주고받는 상황이 필요한 경우에 사용
 - 실시간 동영상 스트리밍이나 온라인 게임 등에 자주 사용


## 소켓 API 실행 흐름

클라이언트 소켓(Client Socket)은 처음 소켓(Socket)을 생성(Create)
서버 측에 연결(Connect)을 요청
서버 소켓에서 연결이 받아들여지면 데이터를 송수신(Send/Recv)
모든 처리가 완료되면 소켓(Socket)을 닫는다(Close)

### 서버 소켓 처리 과정
1. 소켓을 생성하는 것
2. 서버가 사용할 IP주소와 포트 번호를 생성한 소켓에 결합(Bind)
3. 클라이언트로부터 연결 요청이 수신되는지 주시(Listen)
4. 요청이 수신되면 요청을 받아들여(Accepy) 데이터 통신을 위한 소켓 생성
5. 새로운 소켓을 통해 연결이 수립되면, 클라이언트와 마찬가지로 데이터를 송수신(Send/Recv)
6. 데이터 송수신이 완료되면 소켓을 닫는다(Close)

## 클라이언트 소켓 프로그래밍
1. 클라이언트 소켓 생성 socket( )
소켓 통신을 위해 가장 먼저 해야 할 일은 소켓 생성
소켓의 종류를 지정할 수 있음
TCP 소켓을 위한 스트림 타입
UDP 소켓을 위한 데이터그램 타입
family, raw 타입도 존재

최초 소켓이 만들어진 시점 “연결 대상”에 대한 정보가 없음
이 소켓을 연결할 대상을 지정 (IP : PORT) 하기 위해서
생성한 소켓을 사용하여 connect( ) API를 호출해야 한다

2. 연결 요청 connect( )
connect( ) API는 “IP주소”와 “포트번호”로 식별되는 대상(Target)으로 연결 요청을 보냄

connect( ) API는 블록(Block) 방식으로 동작
연결 요청에 대한 결과 (성공, 거절, 시간초과 등)가 결정 되기 전에는 connect( )의 실생이 끝나지 않음
 - connect( ) API가 실행되자마자 실행 결과와 관계없이 리턴될 것이라 가정해서 안됨

connect( ) API 호출이 성공하면, send( ) / recv( ) API를 통해 데이터 송수신이 가능

3. 데이터 송수신 send( ) / recv( )
연결된 데이터를 보낼 때 send( ) API
데이터를 받을 때 recv( ) API

send( ) / recv( ) API는 모두 블록 방식으로 동작하며
API가 모두 실행 결과가 경정되기 전까지 API가 리턴되지 않음

send( ) API는 보내는 주체가 자신이기 때문에 보내는 양, 보내는 시간 등을 알 수 있지만, recv( ) API는 통신대상이 언제, 어떤 데이터를 보내는지 특정이 불가해 실행 시 언제 끝날지 모르는 상태가 된다

데이터 수신을 위한 recv( ) API는 별도의 스레드에서 실행
 - 소켓의 생성과 연결이 완료된 후, 새로운 스레드를 하나 만든 후 그곳에서 recv( )를 실행하고 데이터 수신을 기다림

send( ) / recv( ) API를 통해 데이터 송수신 과정이 완료되면, close( ) API를 사용하여 소켓을 닫는다

4. 소켓 닫기 close( ) API
송수신이 끝난 경우, 소켓을 닫기 위해 close( ) API를 호출
close( ) API에 의해 닫힌 소켓은 더 이상 유효한 소켓이 아니기 때문에, 해당 소켓을 사용하여 데이터 송수신을 할 수 없다

소켓 연결이 종료된 후 다시 데이터를 주고받고싶다면, 소켓 생성, 연결 과정을 다시 거쳐야 한다


## 서버 소켓 프로그래밍
1. 서버 소켓 생성 socket( )
클라이언트 소켓과 마찬가지로, 서버 소켓을 사용하려면 최초에 소켓을 생성

2. 서버 소켓 바인딩 bind( )
bind( ) API에 사용되는 인자는 소켓과 포트 번호(또는 IP주소 + 포트 번호)
소켓과 포트 번호의 결합을 의미함

각 소켓은 시스템이 관리하는 포트 (0 ~ 65535) 중 하나의 포트 번호를 사용
![image](https://user-images.githubusercontent.com/97201374/185395210-0b6c102a-22e7-4144-a2ec-9562f31f2e08.png)

소켓이 사용하는 포트 번호가 중복된다면, 네트워크를 통해 A 포트로 데이터가 수신될 때, 어떤 소켓이 처리해야 하는지 결정할 수 없는 문제가 발생

이러한 이유 등으로 운영체제에서는 소켓들이 중복된 포트 번호를 사용하지 않도록, 내부적으로 포트 번호와 소켓 연결 정보를 관리

bind( ) API는 해당 소켓이 지정된 포트 번호를 사용할 것이라는 것을 운영체제에 요청하는 API이다
만약, 지정된 포트 번호를 다른 소켓이 사용하고 있다면 bind( ) API는 에러를 리턴

운영체제가 특정 포트 번호를 서버 소켓이 사용하도록 만들기 위해
소켓과 포트 번호를 결합해야 하는데, 이 때 사용하는 API가 bind이다

bind( ) API를 호출하는 것을 “소켓 바인드” 또는 “소켓 바인딩”이라고도 부름

3, 클라이언트 연결 요청 대기 listen( )
bind( ) 결합을 하고 나면, 서버 소켓은 클라이언트의 요청을 받아들일 준비가 완료
클라이언트에 의한 연결 요청이 수신될 때까지 기다리는데 listen( ) API가 역할을 수행

listen( ) API는 서버 소켓에 bind된 포트 번호를 클라이언트의 연결 요청이 있는지 확인하며, 대기 상태에 머무른다
클라이언트에서 호출된 connect( ) API에 의해 연결 요청이 수신되는지 대기하고 있다가
요청이 수신되면, 그 때 대기 상태를 종료하고 리턴

listen( ) API가 대기상태에서 빠져나오는 두 가지 경우
 - 클라이언트 요청이 수신되는 경우
 - 에러가 발생하는 경우

listen( ) API가 성공한 경우에도 리턴 값에 클라이언트의 요청 정보는 들어있지 않음
listen( ) API의 리턴 캇으로 판단할 수 있는 것은 클라이언트 연결 요청이 수신되었는지
성공(SUCCESS), 에러 발생(FAIL) 두 가지이다

대신 클라이언트 연결 요청에 대한 정보는 시스템 내부적으로 관리되는 큐에 쌓이게 되는데, 이 시점에서 클라이언트와의 연결은 아직 완전히 연결되지 않은 (not ESTABLISHED state) 대기 상태이다

대기 중인 연결 요청을 큐로부터 꺼내와 연결 완료를 위해서 accept( ) API를 호출해야 함

4. 클라이언트 연결 수립 accept( )
listen( ) API에 의해 연결 요청 확인과 문제없는 리턴으로 클라이언트와 연결 과정이 모두 완료된 것이 아니다

실질적인 소켓 연결(Connection)을 수립하는 절차가 남았음
최종적으로 연결 요청을 받아들이는 역할을 수행하는 것은 accept( ) API이다

＊ 주의할 점
 - 최종적으로 데이터 통신을 위해 연결되는 소켓이
 - 앞서 bind( ) API, listen( ) API에서 사용한 서버 소켓이 아니다
 - 최종적으로 클라이언트 소켓과 연결이 만들어지는 소켓은 accept( ) API 내부에서 새로 만들어지는 소켓이다

→ 서버 소켓의 핵심 역할은 클라이언트의 연결 요청을 수신하는 것
 - 이를 위해서 bind( ) 및 listen( )을 통해 소켓에 포트 번호를 바인딩하고 요청 대기 큐를 생성하여 클라이언트의 요청을 대기하였다
 - 그리고 accept( ) API에서, 데이터 송수신을 위한 새로운 소켓을 만들고
 - 서버 소켓의 대기 큐에 쌓여있는 첫 번째 연결 요청을 매핑시킨다
 - 여기까지가 하나의 연결 요청을 처리하기 위한 서버 소켓의 역할
 - 서버 소켓의 입장에서는 또 다른 연결 요청 처리를 위해 디기하거나 서버 소켓을 닫는 일밖에 없음

실질적인 데이터 송수신은 accept( ) API에서 생성된, 연결이 수립된 소켓을 통해 처리

5. 데이터 송수신 send( ) / recv( )
데이터를 송수신하는 과정은 클라이언트 소켓 처리 과정과 동일

6. 소켓 연결 종료 close( )
클라이언트 소켓 처리 과정과 마찬가지로 소켓을 닫기 위해서 close( ) API를 호출

but, 서버 소켓에서는 close( ) 대상이 하나만 있는 것이 아니다
 - 최초 socket( ) API를 통해 생성한 서버 소켓
 - accept( ) API 호출에 의해 생성된 소켓도 관리해야 함

### 교차 출처 리소스 공유 (CORS – Corss-Origin Resource Sharing)
 - 추가 HTTP 헤더를 사용하여, 한 출처에서 실행 중인 웹 애플리케이션이 다른 출처의 선택한 자원에 접근할 수 있는 권한을 부여하도록 브라우저에 알려주는 체제
 - 웹 애플리케이션은 리소스가 자신의 출처(도메인, 프로토콜, 포트)와 다를 때, 교차 출처 HTTP 요청을 실행

보안상의 이유로 브라우저는 스크립트에서 시작한 교차 출처 HTTP 요청을 제한

![image](https://user-images.githubusercontent.com/97201374/185395224-1ad9707c-9208-4bcf-ab06-6bc9d3042764.png)


CORS 체제는 브라우저와 서버 간의 안전한 교차 출처 요청 및 데이터 전송을 지원하며,
최신 브라우저는 XMLHttpRequest 또는 Fetch와 같은 API에서 CORS를 사용하여 교차 출처 HTTP 요청의 위험을 완화

＊ Fetch
 – 네트워크 통신을 포함한 리소스 취득을 위한 인터페이스가 정의
 - Fetch에는 일반적인 오브젝트로 Request와 Response가 포함
 - service worker나 Cache API같이 response와 request 객체를 다루는 API
 - 독자적으로 response를 발생시키는 경우에 사용

## 웹 통신 흐름

1. 사용자의 URL 요청
 - 사용자가 주소를 요청

2. 브라우저의 URL 분석
 - URL은 인터넷에서 자원의 위치 (Uniform Resource Locator)를 나타낸다
 - URL의 기본적인 구조

![image](https://user-images.githubusercontent.com/97201374/185395286-d02f6b87-a444-4a09-8ce2-476732f60f71.png)


☞ 프로토콜 Protocol
 - 브라우저가 어떤 프로토콜을 사용하는지 ex) http, https, ftp

☞ 도메인 네임 Domain Name
 - 어떤 웹 서버가 요구되는지, 도메인 이름이 아닌 IP를 입력해도 된다

☞ 포트 Port
 - 기술적으로 웹 서버에서 자원에 접근하기 위해 사용되는 gate
 - 만약 웹 서버가 HTTP(80포트), HTTPS(443포트)를 사용한다면 포트 번호를 생략할 수 있다

☞ 경로 Path to the file
 - 자원에 대한 경로로 초기 웹에서는 웹 서버 상에서의 물리적 파일 위치를 나타냄
 - 요즘에는 실제 물리적 경로 x / 웹 서버에서 추상화하여 보여준다

☞ 파라미터 Parametas
 - & 기호들로 구분된 key / value 짝을 이룬 리스트이다
 - 웹 서버 자원을 반환하기 전에 추가적인 작업을 위해 파라미터를 사용할 수 있다

☞ 닻 Anchor
 - 일종의 자원의 북마크
 - 웹에서 해당 북마크 지점을 보여주기 위해 브라우저에게 방향을 알려주는 역할을 함
 - 부분 식별자로 알려져 요청이 서버에 절대 보내지지 않는다

3. HSTS 목록 조회 (HTTP Strict Transport Security)
 - HTTP 대신 HTTPS만을 사용해야 한다는 보안 기능
 - HTTP로 요청이 올 경우 “Strict Transport Security”라는 필드를 포함하여 응답 후
 - 이를 확인한 브라우저는 해당 서버에 요청할 때 HTTPS만을 통해 통신하게 된다
 - 그리고 자신의 HSTS 캐시에 해당 URL을 저장, 이를 HSTS 목록이라 부른다

4. URL을 IP 주소로 변환
 - 도메인 이름으로 입력받은 주소로는 컴퓨터끼리 통신 할 수 없다
  이를 인터넷 상에서 컴퓨터가 읽을 수 있는 IP주소로 변환해야 서로 통신이 가능

5. 라우터를 통해 해당 서버의 게이트웨이까지 이동

DNS 서버에게 IP 주소를 받아 이제 해당 서버로 요청
 - 요청을 보낼 IP 주소를 임의로 10.20.30.6 으로 가정
 - IP 주소로 가야하는건 알지만 어떻게 갈지 경로를 알 수 없다
 - 어떻게 이동할지 네트워크 장비인 라우터의 라우팅을 통해 이뤄짐

![image](https://user-images.githubusercontent.com/97201374/185395306-65b4708e-61c9-404d-9b97-f09174e53b98.png)


 - 라우터에서는 라우팅 테이블을 통해 해당 요청이 어떤 경로를 통해서 갈지 경로 지정
 - 이를 통해 요청은 10.20.30.6을 찾아간다

6. ARP를 통해 IP 주소를 MAC 주소로 변환
 - 주소 결정 프로토콜(Address Resolution Protocol)은 네트워크 상에서 IP 주소를
 - 물리적 네트워크 주소로 대응시키기 위해 사용되는 프로토콜
 - 실질적인 통신을 위해서는 논리 주소인 IP 주소를 물리 주소인 MAC 주소로 변환

7. 대상 서버와 TCP 소켓 연결
 - 대상 서버와 통신하기 위해 TCP 소켓 연결을 진행
 - 소켓 연결은 3-way-handshake 과정을 통해 이뤄짐

![image](https://user-images.githubusercontent.com/97201374/185395332-3e10a2e0-56dd-4846-8289-f0998dcbe9dd.png)

☞ SYN
 - 첫 번째 단계에서 클라이언트는 서버와 연결을 설정하기 원하므로 SYN이 포함된 세그먼트를 서버에 전송하여 클라이언트가 통신을 시작할 가능성이 있고, 어떤 시퀀스로 통신을 시작할 것인지 서버에 알림
☞ SYN + ACK 
 - 서버는 SYN-ACK 신호 비트가 설정된 클라이언트 요청에 응답
 - ACK는 수신한 세그먼트의 응답을 나타내고
 - SYN은 세그먼트를 시작할 가능성이 있는 시퀀스 번호를 나타냄
☞ ACK
 - 마지막 부분에서 클라이언트는 서버의 응답을 확인하고 둘 다 실제 데이터 전송을 시작할 안정적인 연결을 설정
![image](https://user-images.githubusercontent.com/97201374/185395357-79bd45a5-c2c9-4f00-a7d1-735a25d4844e.png)

 - HTTPS 요청을 위해서는 TLS 핸드 쉐이킹이 추가된다
 - 이를 통해 서버와 클라이언트는 암호화 통신을 진행할 수 있다

8. HTTP (HTTPS) 프로토콜로 요청, 응답
 - 연결이 확정되었으니 해당 페이지를 서버에 요청
 - 서버에서 해당 요청을 받고, 수락할 수 있는지 검사
 - 서버는 이 요청에 대한 응답을 생성하여 브라우저에 전달

9. 브라우저에서 응답을 해석
 - 서버에서 응답한 내용들은 HTML, CSS, Javascript 등으로 이루어진다

 
